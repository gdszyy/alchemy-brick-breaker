<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÂõûËÅ≤ÁÖâÈáëÂ∏´ (Echo Alchemist) - Ver 5.6 (Fix Hit Progress)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+TC:wght@400;700&display=swap');

        body {
            background-color: #020617;
            color: #e2e8f0;
            font-family: 'Noto Serif TC', serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            background: #0f172a; 
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Animated Phase Title */
        #phase-title-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            text-align: center;
            width: 100%;
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        #phase-title-container.minimized {
            top: max(20px, env(safe-area-inset-top));
            left: 20px;
            transform: translate(0, 0) scale(0.4);
            transform-origin: top left;
            opacity: 0.6;
        }

        .phase-text {
            font-family: 'Cinzel', serif;
            font-size: 3.5rem;
            font-weight: bold;
            color: #facc15;
            text-shadow: 0 0 30px rgba(250, 204, 21, 0.6);
            background: linear-gradient(to bottom, #fef08a, #ca8a04);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 2px;
        }
        .phase-sub {
            font-size: 1rem;
            color: #94a3b8;
            margin-top: 0.5rem;
            opacity: 1;
            transition: opacity 0.5s;
        }
        .minimized .phase-sub { opacity: 0; }

        /* UI Overlays */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding-top: max(70px, env(safe-area-inset-top)); /* Space for Top Bar */
            padding-bottom: env(safe-area-inset-bottom);
            transition: opacity 0.3s;
        }

        /* Top Bar */
        .top-bar {
            position: absolute;
            top: max(10px, env(safe-area-inset-top));
            right: 10px; 
            display: flex;
            gap: 8px;
            z-index: 90;
            pointer-events: auto;
        }

        .stat-pill {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid #475569;
            padding: 0.3rem 0.8rem;
            border-radius: 999px;
            font-family: 'Cinzel', serif;
            color: #e2e8f0;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 4px;
            backdrop-filter: blur(4px);
        }
        .stat-highlight { color: #facc15; font-weight: bold; }

        .btn-icon {
            width: 32px; height: 32px;
            display: flex; align-items: center; justify-content: center;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid #475569;
            border-radius: 50%;
            color: #94a3b8;
            cursor: pointer;
        }

        /* Bottom Panel (Phase 1) */
        .bottom-panel {
            background: rgba(15, 23, 42, 0.98);
            border-top: 1px solid #475569;
            padding: 12px;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.5);
        }

        /* Hit Bar */
        .hit-container {
            display: flex; align-items: center; gap: 8px;
            font-size: 0.75rem; color: #94a3b8;
        }
        .hit-bar-bg {
            flex: 1; height: 8px; background: #334155; border-radius: 4px; overflow: hidden;
        }
        .hit-bar-fill {
            height: 100%; background: linear-gradient(90deg, #f59e0b, #fbbf24);
            width: 0%; transition: width 0.2s;
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        /* Marble Queue & Recipe */
        .queue-container {
            display: flex; align-items: center; gap: 4px;
            border-right: 1px solid #334155; padding-right: 10px;
            margin-right: 4px;
        }
        .queue-dot {
            width: 20px; height: 20px; border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Recipe Cards */
        .recipe-scroll {
            display: flex; gap: 8px; overflow-x: auto;
            scrollbar-width: none;
        }
        .recipe-card {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid #475569;
            border-radius: 6px;
            padding: 4px 8px;
            min-width: 90px;
            flex-shrink: 0;
            font-size: 0.7rem;
        }
        .recipe-card.active {
            background: rgba(50, 60, 90, 0.9);
            border-color: #fbbf24;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.1);
        }

        /* Selection Grid */
        .marble-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;
            padding: 20px;
            pointer-events: auto;
        }
        .select-card {
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid #475569;
            border-radius: 12px;
            aspect-ratio: 3/4;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
        }
        .select-card.selected {
            border-color: #fbbf24; background: rgba(50, 60, 90, 0.9);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.3);
            transform: translateY(-4px);
        }
        .select-icon {
            width: 48px; height: 48px; 
            border-radius: 50%; margin-bottom: 8px;
            box-shadow: inset -2px -2px 6px rgba(0,0,0,0.5), 2px 2px 6px rgba(255,255,255,0.3);
            flex-shrink: 0;
        }

        /* Buttons */
        .btn-main {
            background: linear-gradient(135deg, #4f46e5 0%, #3730a3 100%);
            color: white; font-family: 'Cinzel', serif;
            padding: 12px; border-radius: 8px; width: 80%;
            text-align: center; margin: 0 auto;
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.4);
            pointer-events: auto;
            transition: opacity 0.2s;
        }
        .btn-main:disabled { opacity: 0.5; filter: grayscale(1); }

        /* Toast */
        #toast {
            position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: #fff; padding: 8px 16px; border-radius: 20px;
            pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 200;
            border: 1px solid #475569;
        }
        .toast-visible { opacity: 1 !important; }
        
        /* Recipe HUD - Floating (Combat Phase) */
        .recipe-hud-floating {
            position: absolute;
            bottom: max(20px, env(safe-area-inset-bottom)); 
            right: 16px;
            width: 160px; 
            display: flex;
            flex-direction: column-reverse;
            gap: 6px;
            pointer-events: auto; 
            z-index: 20;
        }
        .recipe-card.current {
            background: rgba(50, 60, 90, 0.9);
            border-color: #fbbf24;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.2);
            transform: scale(1.05);
        }
        .recipe-card.queue { opacity: 0.5; transform: scale(0.95); }
        .mat-row { display: flex; align-items: center; margin-top: 2px; }
        
        /* Ammo Queue Dots */
        .ammo-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin: 0 2px;
            border: 1px solid #fff;
            opacity: 0.3;
            background: rgba(255,255,255,0.1);
        }
        .ammo-indicator.active { opacity: 1; box-shadow: 0 0 5px #fff; background: #fff; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Phase Title Animation -->
    <div id="phase-title-container">
        <div id="phase-title" class="phase-text">ÂõûËÅ≤ÁÖâÈáëÂ∏´</div>
        <div id="phase-sub" class="phase-sub">ÈªûÊìäÈñãÂßã</div>
    </div>

    <!-- Top Bar (Persistent) -->
    <div class="top-bar">
        <div class="stat-pill">R <span id="round-num" class="stat-highlight">1</span></div>
        <div class="stat-pill">Score <span id="score-num" class="stat-highlight">0</span></div>
        <button id="speed-btn" class="btn-icon">‚è©</button>
        <button id="mute-btn" class="btn-icon">üîä</button>
    </div>

    <div id="toast"></div>

    <!-- Recipe HUD Container (Position managed by CSS classes) -->
    <div id="recipe-hud-container" class="hidden" onclick="game.toggleHud()"></div>

    <!-- Phase 0: Selection -->
    <div id="phase-selection" class="ui-overlay active-phase" style="display: flex;">
        <div class="flex-1 flex flex-col justify-center">
            <div id="marble-selection-grid" class="marble-grid"></div>
        </div>
        <div class="pb-8 w-full flex flex-col items-center pointer-events-auto">
            <p class="text-sm text-slate-400 mb-4">Â∑≤ÈÅ∏Êìá: <span id="selected-count" class="text-white font-bold">0</span> / 3</p>
            <button id="confirm-selection-btn" class="btn-main" disabled>ÈñãÂßãÁÖâÈáë</button>
        </div>
    </div>

    <!-- Phase 1: Gathering -->
    <div id="phase-gathering" class="ui-overlay" style="display: none;">
        <div class="absolute top-24 w-full text-center pointer-events-none">
            <p class="text-xs text-cyan-100/40">ÈªûÊìä‰∏äÊñπÂçÄÂüüÈáãÊîæ</p>
        </div>
        
        <!-- Integrated Bottom Panel -->
        <div class="bottom-panel">
            <!-- Hit Charge -->
            <div class="hit-container">
                <span class="whitespace-nowrap">ÈÄ£ÊìäÂÖÖËÉΩ <span id="hit-text" class="text-amber-400">0/5</span></span>
                <div class="hit-bar-bg"><div id="hit-bar" class="hit-bar-fill"></div></div>
            </div>

            <!-- Queue & Recipes -->
            <div class="flex items-center">
                <div class="queue-container" id="gathering-queue"></div>
                <div class="flex-1 overflow-hidden">
                     <div id="gathering-hud-mount" class="recipe-scroll"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Phase 3: Combat -->
    <div id="phase-combat" class="ui-overlay" style="display: none;">
        <div class="text-center mt-4 pointer-events-none">
            <!-- Multiplier Display -->
            <div id="multiplier-display" class="mt-2 text-2xl font-bold text-yellow-400 opacity-0 transition-opacity drop-shadow-md">
                COMBO <span id="multiplier-val">x1.0</span>
            </div>
        </div>

        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none text-center w-full z-20 px-4" id="combat-message"></div>

        <!-- Left Stats -->
        <div class="absolute bottom-6 left-4 bg-slate-900/90 p-3 rounded-xl border border-purple-500/30 backdrop-blur-sm pointer-events-none shadow-lg w-32">
            <div class="text-xs text-purple-300 mb-1 font-bold">Áï∂ÂâçÈ≠îËó•</div>
            <div id="current-bullet-stats" class="text-xs text-white space-y-1 font-mono"></div>
        </div>
        
        <!-- Right Queue -->
        <div class="absolute bottom-6 right-4 bg-slate-900/90 p-3 rounded-xl border border-purple-500/30 backdrop-blur-sm pointer-events-none shadow-lg">
            <div class="text-xs text-purple-300 mb-1 font-bold">Â∫èÂàó</div>
            <div class="flex gap-1" id="ammo-queue"></div>
        </div>
    </div>
</div>

<script>
// --- CONFIG ---
const CONFIG = {
    colors: {
        bg: '#0f172a',
        peg: '#475569',
        pegActive: '#cbd5e1',
        pegPink: '#f472b6', 
        matBase: '#3b82f6', 
        matBounce: '#22c55e', 
        matPierce: '#ef4444', 
        matScatter: '#facc15', 
        matDamage: '#a855f7', 
        marbleWhite: '#f8fafc',
        marbleRedStripe: '#fca5a5', 
        marbleRainbow: 'linear-gradient(135deg, #fca5a5, #facc15, #4ade80, #60a5fa)', 
        enemy: '#a855f7',
        enemyHit: '#d8b4fe',
        slotRecall: '#a855f7', 
        slotMulticast: '#f97316',
        slotSplit: '#3b82f6',
        
    },
    physics: { gravity: 0.40, friction: 0.99, elasticity: 0.6 },
    probabilities: { white: 0.60, colored: 0.25, redStripe: 0.10, rainbow: 0.05 },
    gameplay: {
        cols: 7, 
        rows: 10,
        startRows: 5, 
        spawnProb: 0.6, 
        spawnMin: 4
    }
};

// --- Sound Manager ---
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.muted = false;
        this.masterGain = this.ctx.createGain();
        this.masterGain.connect(this.ctx.destination);
        this.masterGain.gain.value = 0.3; 
    }
    toggleMute() {
        this.muted = !this.muted;
        this.masterGain.gain.value = this.muted ? 0 : 0.3;
        return this.muted;
    }
    resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
    playTone(freq, type, duration, vol = 1) {
        if (this.muted) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }
    playHit(type) {
        const tones = { 'normal': 400, 'bounce': 600, 'pierce': 300, 'scatter': 800, 'damage': 200, 'pink': 1000 };
        this.playTone(tones[type] || 400, 'sine', 0.1, 0.5);
    }
    playShoot() { this.playTone(150, 'triangle', 0.2, 0.8); this.playTone(600, 'sawtooth', 0.1, 0.3); }
    playExplosion() { if (!this.muted) this.playTone(100, 'sawtooth', 0.4, 0.5); }
    playEnemyHit() { this.playTone(200, 'square', 0.1, 0.4); }
    playPowerup() { this.playTone(1200, 'sine', 0.3, 0.4); setTimeout(() => this.playTone(1800, 'sine', 0.3, 0.4), 100); }
}
const audio = new SoundManager();

// --- Utils ---
class Vec2 {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
    mult(s) { return new Vec2(this.x * s, this.y * s); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    norm() { const m = this.mag(); return m === 0 ? new Vec2(0,0) : new Vec2(this.x/m, this.y/m); }
    dist(v) { return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2)); }
    dot(v) { return this.x * v.x + this.y * v.y; }
    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return new Vec2(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
    }
}

function showToast(msg) {
    const el = document.getElementById('toast');
    el.innerText = msg;
    el.classList.add('toast-visible');
    setTimeout(() => el.classList.remove('toast-visible'), 1500);
}

// --- Game Entities ---
class MarbleDefinition {
    constructor(type, subtype = null) {
        this.type = type; 
        this.subtype = subtype; 
        this.id = Math.random().toString(36).substr(2, 9);
        this.collected = []; 
    }
    getColor() {
        if (this.type === 'white') return '#f1f5f9';
        if (this.type === 'redStripe') return '#f87171';
        if (this.type === 'rainbow') return '#ffffff'; 
        if (this.type === 'colored') {
            if (this.subtype === 'bounce') return CONFIG.colors.matBounce;
            if (this.subtype === 'pierce') return CONFIG.colors.matPierce;
            if (this.subtype === 'scatter') return CONFIG.colors.matScatter;
            if (this.subtype === 'damage') return CONFIG.colors.matDamage;
        }
        return '#fff';
    }
    getName() {
        if (this.type === 'white') return 'Á¥îÊ∑®ÂΩàÁè†';
        if (this.type === 'redStripe') return 'ÁàÜÁ†¥ÂΩàÁè†';
        if (this.type === 'rainbow') return '‰∏ÉÂΩ©Á®úÈè°';
        if (this.type === 'colored') {
            const map = { 'bounce': 'ÂΩàÊÄß', 'pierce': 'Á©øÈÄè', 'scatter': 'Êï£Â∞Ñ', 'damage': 'Â¢ûÂπÖ' };
            return `${map[this.subtype] || ''}ÂêåÂåñ`;
        }
        return 'Êú™Áü•';
    }
}

class SpecialSlot {
    constructor(x, y, width, type) {
        this.x = x; this.y = y; this.width = width; this.height = 12; this.type = type; this.animTimer = 0;
    }
    draw(ctx) {
        this.animTimer += 0.05;
        ctx.save();
        let color = '#fff'; let text = '';
        if (this.type === 'recall') { color = CONFIG.colors.slotRecall; text = "‚Ü∫"; }
        else if (this.type === 'multicast') { color = CONFIG.colors.slotMulticast; text = "+2"; }
        else if (this.type === 'split') { color = CONFIG.colors.slotSplit; text = "‚ëÇ"; }
        
        const glow = Math.sin(this.animTimer) * 5 + 10;
        ctx.shadowBlur = glow; ctx.shadowColor = color; ctx.fillStyle = color; ctx.globalAlpha = 0.3;
        ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
        ctx.globalAlpha = 1.0; ctx.shadowBlur = 0; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.font = 'bold 16px sans-serif'; ctx.fillStyle = '#fff'; ctx.fillText(text, this.x, this.y);
        ctx.restore();
    }
}

class Peg {
    constructor(x, y, type = 'normal') {
        this.pos = new Vec2(x, y); this.radius = 6; this.type = type; this.lit = false; this.litTimer = 0;
    }
    draw(ctx, baseRadius) {
        this.radius = baseRadius;
        ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
        let color = CONFIG.colors.peg;
        switch(this.type) {
            case 'bounce': color = CONFIG.colors.matBounce; break;
            case 'pierce': color = CONFIG.colors.matPierce; break;
            case 'scatter': color = CONFIG.colors.matScatter; break;
            case 'damage': color = CONFIG.colors.matDamage; break;
            case 'pink': color = CONFIG.colors.pegPink; break;
        }
        if (this.lit) { ctx.fillStyle = '#ffffff'; ctx.shadowBlur = 10; ctx.shadowColor = color; } else { ctx.fillStyle = color; ctx.shadowBlur = 0; }
        ctx.fill();
        if (this.type !== 'normal') { ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 1.5; ctx.stroke(); }
        if (this.type === 'pink') { ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius + 3, 0, Math.PI * 2); ctx.strokeStyle = CONFIG.colors.pegPink; ctx.lineWidth = 1.5; ctx.stroke(); }
    }
    hit() { this.lit = true; this.litTimer = 15; audio.playHit(this.type); }
    update() { if (this.litTimer > 0) this.litTimer--; else this.lit = false; }
}

class DropBall {
    constructor(x, y, marbleDef, session) {
        this.pos = new Vec2(x, y); this.vel = new Vec2((Math.random() - 0.5) * 2, 2); this.radius = 12; this.active = true; this.def = marbleDef; this.session = session;
        this.isRainbowShard = false; this.portalCooldown = 0; this.hitCount = 0; this.canTriggerSplitSlot = true;
    }
    update(pegs, slots, width, height, timeScale) {
        if (!this.active) return null;
        if (this.portalCooldown > 0) this.portalCooldown -= timeScale;
        let gravityStep = new Vec2(0, CONFIG.physics.gravity * timeScale);
        this.vel = this.vel.add(gravityStep);
        this.pos = this.pos.add(this.vel.mult(timeScale));
        this.vel = this.vel.mult(Math.pow(CONFIG.physics.friction, timeScale));

        if (this.pos.x < this.radius) { this.pos.x = this.radius; this.vel.x *= -0.6; }
        if (this.pos.x > width - this.radius) { this.pos.x = width - this.radius; this.vel.x *= -0.6; }
        if (this.pos.y > height + this.radius) { this.active = false; return 'finished'; }

        for (let slot of slots) {
            if (this.portalCooldown <= 0) {
                let dx = Math.abs(this.pos.x - slot.x);
                let dy = Math.abs(this.pos.y - slot.y);
                if (dy < 12 && dx < slot.width / 2) {
                    this.portalCooldown = 40; 
                    if (slot.type === 'recall') {
                        this.pos.y = 80; this.vel.y = 2; this.portalCooldown = 60; audio.playPowerup(); game.createExplosion(slot.x, slot.y, CONFIG.colors.slotRecall); showToast("ÊôÇÁ©∫ÂõûÊ∫ØÔºÅ");
                    } else if (slot.type === 'multicast') {
                        if (this.session.multicastAdded.indexOf(slot) === -1) { 
                            this.session.multicast += 2; audio.playPowerup(); game.createExplosion(slot.x, slot.y, CONFIG.colors.slotMulticast); showToast("ÈÄ£Á∫åÁôºÂ∞Ñ+2ÔºÅ");
                        }
                    } else if (slot.type === 'split') {
                        if (this.canTriggerSplitSlot) {
                            this.active = false; audio.playPowerup(); game.createExplosion(slot.x, slot.y, CONFIG.colors.slotSplit); return { action: 'split', pos: this.pos, vel: this.vel, def: this.def };
                        }
                    
                }
            }
        }
        for (let peg of pegs) {
            let dist = this.pos.dist(peg.pos); let minDist = this.radius + peg.radius;
            if (dist < minDist) {
                let n = this.pos.sub(peg.pos).norm(); this.pos = peg.pos.add(n.mult(minDist));
                let elasticity = CONFIG.physics.elasticity; if (peg.type === 'pink') elasticity *= 1.8; 
                let d = this.vel.dot(n); this.vel = this.vel.sub(n.mult(2 * d)).mult(elasticity); this.vel.x += (Math.random() - 0.5) * 0.5; peg.hit();
                this.hitCount++; this.session.currentHits++; game.createHitFeedback(this.pos.x, this.pos.y);
                if (this.session.currentHits >= this.session.nextTriggerThreshold) {
                    this.session.currentHits = 0; this.session.multicast++; this.session.nextTriggerThreshold++; showToast(`ÂÖÖËÉΩÔºÅ‰∏ã‰∏ÄÊ¨°: ${this.session.nextTriggerThreshold}`); audio.playPowerup();
                }
                // if (this.def.type === 'colored' && this.def.subtype) { peg.type = this.def.subtype; } // ÁßªÈô§ÂêåÂåñÊïàÊûú
                if (this.def.type === 'rainbow' && !this.isRainbowShard) { this.active = false; return { action: 'rainbow_split', pos: this.pos, vel: this.vel }; }
                if (peg.type !== 'normal' && peg.type !== 'pink') { this.session.collected.push(peg.type); this.def.collected.push(peg.type); }
            }
        }
        return null;
    }
    draw(ctx) {
        if (!this.active) return;
        ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
        if (this.def.type === 'rainbow') {
            const grad = ctx.createLinearGradient(this.pos.x-5, this.pos.y-5, this.pos.x+5, this.pos.y+5); grad.addColorStop(0, '#fca5a5'); grad.addColorStop(0.5, '#facc15'); grad.addColorStop(1, '#60a5fa'); ctx.fillStyle = grad;
        } else if (this.def.type === 'redStripe') { ctx.fillStyle = '#f87171'; } else { ctx.fillStyle = this.def.getColor(); }
        ctx.fill();
        if (this.def.type === 'redStripe') { ctx.strokeStyle = '#7f1d1d'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.pos.x - 4, this.pos.y - 4); ctx.lineTo(this.pos.x + 4, this.pos.y + 4); ctx.stroke(); }
        ctx.shadowBlur = 0;
    }
}

class Enemy {
    constructor(x, y, w, h, hp, maxHp) {
        this.pos = new Vec2(x, y); this.width = w; this.height = h; this.hp = hp; this.maxHp = maxHp || hp; this.active = true; this.hitTimer = 0; this.dropTargetY = y; this.justSpawned = true; 
    }
    update(timeScale) { if (this.pos.y < this.dropTargetY) { this.pos.y += 3 * timeScale; } if (this.hitTimer > 0) this.hitTimer -= timeScale; if(this.justSpawned) { this.justSpawned = false; } }
    advance(amount) { this.dropTargetY += amount; }
    draw(ctx) {
        if (!this.active) return;
        ctx.save(); ctx.translate(this.pos.x, this.pos.y);
        if (this.hitTimer > 0) { const shake = this.hitTimer * 0.5; ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); }
        const w = this.width - 4; const h = this.height - 4; const hpRatio = this.hp / this.maxHp;
        ctx.fillStyle = `rgba(168, 85, 247, ${0.4 + hpRatio * 0.6})`; ctx.strokeStyle = '#e9d5ff'; ctx.lineWidth = 2;
        const r = 6; ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h, r); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(Math.ceil(this.hp), 0, 0); ctx.restore();
    }
    takeDamage(amount) { this.hp -= amount; this.hitTimer = 10; audio.playEnemyHit(); if (this.hp <= 0) { this.active = false; return true; } return false; }
    getBounds() { return { left: this.pos.x - this.width/2, right: this.pos.x + this.width/2, top: this.pos.y - this.height/2, bottom: this.pos.y + this.height/2 }; }
}

class Projectile {
    constructor(x, y, vel, config, isCopy = false) {
        this.pos = new Vec2(x, y); this.vel = new Vec2(vel.x, vel.y); this.config = config; this.radius = isCopy ? 8 : 11; this.active = true; this.isCopy = isCopy;
        this.bouncesLeft = config.bounce || 0; this.piercesLeft = config.pierce || 0; this.lastHit = null; this.destroyed = false; this.lifeTime = 60 * 15; 
    }
    update(width, height, enemies, spawnCallback, timeScale) {
        if (!this.active) return;
        this.lifeTime -= timeScale; if(this.lifeTime <= 0) { this.destroy(spawnCallback); return; }
        this.pos = this.pos.add(this.vel.mult(timeScale));
        if (this.pos.x < this.radius) { this.pos.x = this.radius; this.vel.x *= -1; }
        if (this.pos.x > width - this.radius) { this.pos.x = width - this.radius; this.vel.x *= -1; }
        if (this.pos.y < this.radius) { this.pos.y = this.radius; this.vel.y *= -1; }
        if (this.pos.y > height - this.radius) { this.pos.y = height - this.radius; this.vel.y *= -1; }
        if (this.pos.y > height + 50) { this.destroy(spawnCallback); return; }

        for (let e of enemies) {
            if (!e.active) continue;
            let bounds = e.getBounds();
            if (this.pos.x > bounds.left && this.pos.x < bounds.right && this.pos.y > bounds.top && this.pos.y < bounds.bottom) {
                if (this.lastHit !== e) {
                    this.onHit(e, enemies); this.lastHit = e;
                    if (this.piercesLeft > 0) { this.piercesLeft--; } else if (this.bouncesLeft > 0) { this.bouncesLeft--; let dx = this.pos.x - e.pos.x; let dy = this.pos.y - e.pos.y; if (Math.abs(dx) > Math.abs(dy)) this.vel.x *= -1; else this.vel.y *= -1; } else { this.destroy(spawnCallback); return; }
                }
            } else { if (this.lastHit === e) this.lastHit = null; }
        }
    }
    onHit(enemy, allEnemies) {
        const dmg = this.isCopy ? this.config.damage * 0.5 : this.config.damage;
        const killed = enemy.takeDamage(dmg); game.recordDamage(dmg); 
        if (killed) { game.addScore(enemy.maxHp); }
        if (this.config.explosive) {
            game.createShockwave(this.pos.x, this.pos.y); game.createExplosion(this.pos.x, this.pos.y, '#f87171'); audio.playExplosion();
            allEnemies.forEach(other => {
                if (other !== enemy && other.active && this.pos.dist(other.pos) < 100) { const k = other.takeDamage(dmg * 0.5); game.recordDamage(dmg * 0.5); if (k) game.addScore(other.maxHp); }
            });
        }
    }
    destroy(spawnCallback) {
        this.active = false; this.destroyed = true;
        if (this.config.chainPayload && !this.isCopy) {
            let nextVel = this.vel; if (nextVel.mag() < 1) nextVel = new Vec2(0, 5);
            spawnCallback({ x: this.pos.x, y: this.pos.y, vel: nextVel.norm().mult(10), config: this.config.chainPayload });
        }
    }
    draw(ctx) {
        ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
        if (this.config.explosive) ctx.fillStyle = CONFIG.colors.matPierce; else if (this.config.pierce > 0) ctx.fillStyle = CONFIG.colors.matPierce; else if (this.config.bounce > 0) ctx.fillStyle = CONFIG.colors.matBounce; else if (this.config.damage > 2) ctx.fillStyle = CONFIG.colors.matDamage; else ctx.fillStyle = CONFIG.colors.matBase;
        ctx.fill(); if (this.config.explosive) { ctx.strokeStyle = '#fca5a5'; ctx.lineWidth = 2; ctx.stroke(); }
    }
}

class Particle {
    constructor(x, y, color) { this.pos = new Vec2(x, y); this.vel = new Vec2((Math.random()-0.5)*5, (Math.random()-0.5)*5); this.life = 1.0; this.color = color; }
    update(timeScale) { this.pos = this.pos.add(this.vel.mult(timeScale)); this.life -= 0.05 * timeScale; }
    draw(ctx) { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, Math.random()*3 + 1, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; }
}

class Shockwave {
    constructor(x, y) { this.x = x; this.y = y; this.radius = 5; this.alpha = 1.0; }
    update(timeScale) { this.radius += 4 * timeScale; this.alpha -= 0.05 * timeScale; }
    draw(ctx) { if(this.alpha <= 0) return; ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fillStyle = `rgba(252, 165, 165, ${this.alpha * 0.5})`; ctx.strokeStyle = `rgba(252, 165, 165, ${this.alpha})`; ctx.lineWidth = 3; ctx.fill(); ctx.stroke(); ctx.restore(); }
}

class FloatingText {
    constructor(x, y, text) { this.pos = new Vec2(x, y); this.text = text; this.life = 1.0; this.vel = new Vec2(0, -1.5); }
    update(timeScale) { this.pos = this.pos.add(this.vel.mult(timeScale)); this.life -= 0.02 * timeScale; }
    draw(ctx) { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = '#fbbf24'; ctx.font = 'bold 16px sans-serif'; ctx.fillText(this.text, this.pos.x, this.pos.y); ctx.globalAlpha = 1.0; }
}

// --- Main Game Controller ---
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => { this.resize(); if (this.phase === 'gathering') this.initPachinko(); });

        this.phase = 'selection'; this.marblesPool = []; this.selectedMarbles = []; this.marbleQueue = []; this.ammoQueue = [];
        this.pegs = []; this.enemies = []; this.specialSlots = []; this.dropBalls = []; this.projectiles = []; this.particles = []; this.shockwaves = []; this.floatingTexts = []; this.rainbowBuffer = [];

        this.isDragging = false; this.dragStart = new Vec2(0,0); this.dragCurrent = new Vec2(0,0); this.lastMousePos = new Vec2(0,0); 
        this.currentSession = null;
        this.gameOver = false; this.defeatLineY = 0; this.timeScale = 1.0; this.round = 1; this.score = 0; this.scoreMultiplier = 1.0;
        this.hudExpanded = false; this.roundDamage = 0; this.prevRoundDamage = 0;

        this.setupInputs(); this.initGameStart(); this.loop();
    }
    resize() {
        const container = document.getElementById('game-container'); this.width = this.canvas.width = container.clientWidth; this.height = this.canvas.height = container.clientHeight; this.defeatLineY = this.height - 150; 
        this.enemyWidth = (this.width / CONFIG.gameplay.cols); this.enemyHeight = 50; 
    }
    initGameStart() {
        const startY = 80; for(let i=0; i<CONFIG.gameplay.startRows; i++) { this.spawnEnemyRowAt(startY + i * this.enemyHeight); }
        this.initSelectionPhase();
    }
    setupInputs() {
        const handler = (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
            const y = (e.touches && e.touches.length > 0) ? e.touches[0].clientY : e.clientY;
            return new Vec2(x - rect.left, y - rect.top);
        };
        this.canvas.addEventListener('mousedown', e => this.handleInputStart(handler(e))); this.canvas.addEventListener('touchstart', e => this.handleInputStart(handler(e)), {passive: false});
        window.addEventListener('mousemove', e => this.handleInputMove(handler(e), e)); window.addEventListener('touchmove', e => this.handleInputMove(handler(e), e), {passive: false});
        window.addEventListener('mouseup', () => this.handleInputEnd()); window.addEventListener('touchend', () => this.handleInputEnd());
        
        document.getElementById('confirm-selection-btn').onclick = () => this.confirmSelection();
        
        const speedBtn = document.getElementById('speed-btn');
        speedBtn.onclick = () => { if (this.timeScale === 1.0) this.timeScale = 2.0; else if (this.timeScale === 2.0) this.timeScale = 0.5; else this.timeScale = 1.0; speedBtn.innerText = `‚è© x${this.timeScale}`; };
        const muteBtn = document.getElementById('mute-btn');
        muteBtn.onclick = () => { audio.resume(); const isMuted = audio.toggleMute(); muteBtn.innerText = isMuted ? 'üîá' : 'üîä'; };
    }
    spawnEnemyRowAt(yPos) {
        const baseHP = 5 + (this.round * 3); const w = this.enemyWidth; const minEnemies = Math.min(CONFIG.gameplay.cols, CONFIG.gameplay.spawnMin + Math.floor(this.round / 4));
        let spawns = []; for(let c=0; c<CONFIG.gameplay.cols; c++) { if (Math.random() < CONFIG.gameplay.spawnProb) spawns.push(c); }
        while(spawns.length < minEnemies) { let c = Math.floor(Math.random() * CONFIG.gameplay.cols); if(!spawns.includes(c)) spawns.push(c); }
        spawns.forEach(c => { let hp = Math.floor(baseHP * (0.8 + Math.random() * 0.4)); this.enemies.push(new Enemy(c * w + w/2, yPos, w, this.enemyHeight, hp)); });
    }
    spawnEnemyRow(count = 1) { for(let i=0; i<count; i++) { this.spawnEnemyRowAt(80 - (i * this.enemyHeight)); } }
    advanceWave() {
        this.enemies.forEach(e => e.advance(this.enemyHeight));
        const rows = new Set(this.enemies.filter(e=>e.active).map(e => Math.floor(e.pos.y))); let spawnCount = 1; if (rows.size < 3) spawnCount = 2; 
        this.spawnEnemyRow(spawnCount); this.round++; this.prevRoundDamage = this.roundDamage; this.roundDamage = 0; document.getElementById('round-num').innerText = this.round; showToast(`Round ${this.round}`);
    }
    recordDamage(amount) { this.roundDamage += amount; }
    addScore(amount) { this.score += Math.floor(amount * this.scoreMultiplier); document.getElementById('score-num').innerText = this.score; this.scoreMultiplier = parseFloat((this.scoreMultiplier + 0.2).toFixed(1)); this.updateMultiplierUI(); }
    resetMultiplier() { this.scoreMultiplier = 1.0; this.updateMultiplierUI(); document.getElementById('multiplier-display').classList.remove('opacity-100'); document.getElementById('multiplier-display').classList.add('opacity-0'); }
    updateMultiplierUI() { const el = document.getElementById('multiplier-val'); el.innerText = `x${this.scoreMultiplier.toFixed(1)}`; const container = document.getElementById('multiplier-display'); container.classList.remove('opacity-0'); container.classList.add('opacity-100'); el.classList.remove('pop-anim'); void el.offsetWidth; el.classList.add('pop-anim'); }
    
    updateUI() {
        document.querySelectorAll('.ui-overlay').forEach(el => { el.style.display = 'none'; el.classList.add('hidden-phase'); el.classList.remove('active-phase'); });
        const activeEl = document.getElementById(`phase-${this.phase}`); if(activeEl) { activeEl.style.display = 'flex'; setTimeout(() => { activeEl.classList.remove('hidden-phase'); activeEl.classList.add('active-phase'); }, 10); }
    }

    switchPhase(newPhase) {
        this.phase = newPhase;
        this.updateUI();
        
        const titleContainer = document.getElementById('phase-title-container');
        const titleText = document.getElementById('phase-title');
        const subText = document.getElementById('phase-sub');
        
        titleContainer.classList.remove('minimized');
        
        let text = "ÂëΩÈÅãÊäâÊìá"; let sub = "ÈÅ∏Êìá‰Ω†ÁöÑÂëΩÈÅã";
        if (newPhase === 'gathering') { text = "Á†îÁ£®ÈöéÊÆµ"; sub = "Êî∂ÈõÜÈ≠îÂäõ"; }
        else if (newPhase === 'combat') { text = "Êà∞È¨•ÈöéÊÆµ"; sub = "ÊäµÁ¶¶È≠îÂÉè"; }
        
        titleText.innerText = text; subText.innerText = sub;
        
        setTimeout(() => { titleContainer.classList.add('minimized'); }, 1200);
    }

    initSelectionPhase() {
        this.switchPhase('selection');
        this.generateMarbleOptions();
        this.selectedMarbles = []; document.getElementById('selected-count').innerText = '0'; document.getElementById('confirm-selection-btn').disabled = true; document.getElementById('recipe-hud-container').classList.add('hidden');
    }
    generateMarbleOptions() {
        const container = document.getElementById('marble-selection-grid'); container.innerHTML = ''; this.marblesPool = [];
        for(let i=0; i<5; i++) {
            const r = Math.random(); let m;
            if (r < CONFIG.probabilities.white) m = new MarbleDefinition('white');
            else if (r < CONFIG.probabilities.white + CONFIG.probabilities.colored) { const sub = ['bounce', 'pierce', 'scatter', 'damage'][Math.floor(Math.random()*4)]; m = new MarbleDefinition('colored', sub); }
            else if (r < 0.95) m = new MarbleDefinition('redStripe'); else m = new MarbleDefinition('rainbow');
            this.marblesPool.push(m);
            const card = document.createElement('div'); card.className = 'select-card'; card.onclick = () => this.toggleMarbleSelection(i, card);
            const icon = document.createElement('div'); icon.className = 'select-icon flex-shrink-0'; icon.style.background = m.type === 'rainbow' ? CONFIG.colors.marbleRainbow : m.getColor();
            const name = document.createElement('div'); name.className = 'text-xs font-bold text-center text-slate-200 mt-2'; name.innerText = m.getName();
            card.append(icon, name); container.appendChild(card);
        }
    }
    toggleMarbleSelection(idx, cardEl) {
        if (this.selectedMarbles.includes(idx)) { this.selectedMarbles = this.selectedMarbles.filter(i => i !== idx); cardEl.classList.remove('selected'); }
        else { if (this.selectedMarbles.length < 3) { this.selectedMarbles.push(idx); cardEl.classList.add('selected'); } }
        const count = this.selectedMarbles.length; document.getElementById('selected-count').innerText = count; document.getElementById('confirm-selection-btn').disabled = count !== 3;
    }
    confirmSelection() { if (this.selectedMarbles.length !== 3) return; this.marbleQueue = this.selectedMarbles.map(i => this.marblesPool[i]); this.startGatheringPhase(); }
    
    startGatheringPhase() {
        this.switchPhase('gathering');
        this.initPachinko(); this.ammoQueue = []; this.dropBalls = []; this.activeMarbleIndex = 0; 
        this.updateHitProgress(0, 5); this.updateGatheringQueueUI(); this.renderRecipeHUD();
    }
    
    initRecipeHUD() { 
        this.renderRecipeHUD(); 
        const container = document.getElementById('recipe-hud-container');
        container.classList.add('hidden');
    }
    toggleHud() { this.hudExpanded = !this.hudExpanded; this.renderRecipeHUD(); }
    
    renderRecipeHUD() {
        const targetId = this.phase === 'gathering' ? 'gathering-hud-mount' : 'recipe-hud-container';
        const hud = document.getElementById(targetId);
        if(!hud) return;
        
        hud.innerHTML = '';
        
        const floatingHud = document.getElementById('recipe-hud-container');
        if (this.phase === 'combat') {
             floatingHud.classList.remove('hidden');
             floatingHud.className = 'recipe-hud-floating'; 
        } else {
             floatingHud.classList.add('hidden');
        }

        let displayList = [];
        if (this.phase === 'combat') {
            displayList = this.ammoQueue.map(r => ({ name: 'È≠îËó•', collected: [ ...Array(r.bounce).fill('bounce'), ...Array(r.pierce).fill('pierce'), ...Array(r.scatter).fill('scatter'), ...Array(r.damage>2?Math.floor((r.damage-2)/2):0).fill('damage') ], isRecipe: true }));
        } else {
            displayList = this.marbleQueue;
        }
        
        if (this.phase === 'combat') {
            if (!this.hudExpanded && displayList.length > 0) {
                 this.renderRecipeCard(hud, displayList[0], true, 'current');
            } else {
                displayList.forEach((item, idx) => {
                   this.renderRecipeCard(hud, item, idx === 0, idx === 0 ? 'current' : 'queue');
                });
            }
        } else {
            displayList.forEach((item, idx) => {
               const isActive = idx === this.activeMarbleIndex;
               this.renderRecipeCard(hud, item, isActive, isActive ? 'current' : 'queue');
            });
        }
    }
    
    renderRecipeCard(container, item, isActive, statusClass) {
        const el = document.createElement('div'); el.className = `recipe-card ${statusClass}`;
        const head = document.createElement('div'); head.className = 'flex items-center justify-between mb-1';
        const name = document.createElement('span'); name.innerText = item.getName ? item.getName() : 'È≠îËó•'; name.className = 'font-bold text-amber-100'; head.appendChild(name);
        const mats = document.createElement('div');
        const counts = {}; if (item.collected) { item.collected.forEach(type => { counts[type] = (counts[type] || 0) + 1; }); }
        const colors = { 'bounce': { c: CONFIG.colors.matBounce, l: 'üü¢', n: 'ÂΩà' }, 'pierce': { c: CONFIG.colors.matPierce, l: 'üî¥', n: 'Á©ø' }, 'scatter': { c: CONFIG.colors.matScatter, l: 'üü°', n: 'Êï£' }, 'damage': { c: CONFIG.colors.matDamage, l: 'üü£', n: 'Âº∑' } };
        Object.keys(counts).forEach(type => { const info = colors[type]; if(!info) return; const row = document.createElement('div'); row.className = 'mat-row text-slate-300'; row.innerHTML = `<span style="color:${info.c}">${info.l}</span> <span class="ml-1">${info.n}${counts[type]}</span>`; mats.appendChild(row); });
        if (Object.keys(counts).length === 0) { mats.innerHTML = '<span class="text-slate-500 text-[9px]">ÁÑ°ÊùêÊñô</span>'; }
        el.append(head, mats); container.appendChild(el);
    }

    initPachinko() {
        const previousPegs = this.pegs || []; const shouldInherit = previousPegs.length > 0;
        this.pegs = []; this.specialSlots = []; 
        const rows = CONFIG.gameplay.rows; 
        const spacingX = this.width / (CONFIG.gameplay.cols + 1); 
        const spacingY = this.height / 18; 
        const startY = 120; 
        
        let grid = []; let pegIndex = 0;
        for (let r = 0; r < rows; r++) {
            const cols = r % 2 === 0 ? CONFIG.gameplay.cols : CONFIG.gameplay.cols - 1; const xOffset = r % 2 === 0 ? spacingX : spacingX * 1.5; let rowPegs = [];
            for (let c = 0; c < cols; c++) {
                let x = xOffset + c * spacingX; let y = startY + r * spacingY; let type = 'normal';
                if (shouldInherit && previousPegs[pegIndex] && previousPegs[pegIndex].type !== 'normal' && previousPegs[pegIndex].type !== 'pink') { if (Math.random() < 0.9) type = previousPegs[pegIndex].type; else type = this.getRandomPegType(); } else { type = this.getRandomPegType(); }
                let p = new Peg(x, y, type); this.pegs.push(p); rowPegs.push(p); pegIndex++;
            }
            grid.push(rowPegs);
        }
        const pinkCount = Math.floor(Math.random() * 5) + 1; for(let i=0; i<pinkCount; i++) { if(this.pegs.length > 0) { const idx = Math.floor(Math.random() * this.pegs.length); this.pegs[idx].type = 'pink'; } }
        const slotTypes = ['recall', 'multicast', 'split'];
        for(let i=0; i<3; i++) {
            let r = Math.floor(Math.random() * 4) + 5; let rowPegs = grid[r]; if (!rowPegs || rowPegs.length < 2) continue;
            let c = Math.floor(Math.random() * (rowPegs.length - 1)); let p1 = rowPegs[c]; let p2 = rowPegs[c+1];
            let slotType = slotTypes[Math.floor(Math.random() * slotTypes.length)]; let cx = (p1.pos.x + p2.pos.x) / 2; let cy = p1.pos.y; let w = Math.abs(p2.pos.x - p1.pos.x) * 0.8;
            if (!this.specialSlots.some(s => Math.abs(s.x - cx) < 20 && Math.abs(s.y - cy) < 20)) { this.specialSlots.push(new SpecialSlot(cx, cy, w, slotType)); }
        }
    }
    getRandomPegType() { let rand = Math.random(); if (rand < 0.08) return 'bounce'; else if (rand < 0.16) return 'pierce'; else if (rand < 0.22) return 'scatter'; else if (rand < 0.28) return 'damage'; return 'normal'; }

    startCombatPhase() {
        this.switchPhase('combat');
        this.updateAmmoUI(); this.resetMultiplier();
    }

    handleInputStart(pos) {
        audio.resume(); this.lastMousePos = pos;
        if (this.phase === 'gathering') {
            if (this.dropBalls.length > 0) { showToast("Á≠âÂæÖÂΩàÁè†ÁµêÊùü"); return; }
            if (this.activeMarbleIndex >= this.marbleQueue.length) return;
            if (pos.y < this.height * 0.4) {
                const marbleDef = this.marbleQueue[this.activeMarbleIndex];
                this.currentSession = { collected: [], multicast: 0, activeBalls: 1, currentHits: 0, nextTriggerThreshold: 5, totalHits: 0, multicastAdded: [] };
                this.updateHitProgress(0, 5);
                this.dropBalls.push(new DropBall(pos.x, 30, marbleDef, this.currentSession));
                this.updateGatheringQueueUI(); audio.playShoot(); 
            } else { showToast("Ë´ãÂú®‰∏äÊñπÂçÄÂüüÈªûÊìä"); }
        } else if (this.phase === 'combat') {
             if (this.ammoQueue.length === 0 && this.projectiles.length === 0 && !this.gameOver) { this.advanceWave(); if (this.checkDefeat()) { this.gameOver = true; } else { document.getElementById('combat-message').innerHTML = ''; this.initSelectionPhase(); } return; }
            if (this.ammoQueue.length > 0 && this.projectiles.length === 0) { this.isDragging = true; this.dragStart = pos; this.dragCurrent = pos; }
        }
    }
    handleInputMove(pos, e) { this.lastMousePos = pos; if (this.isDragging) { this.dragCurrent = pos; e.preventDefault(); } }
    handleInputEnd() {
        if (this.isDragging) { this.isDragging = false; const force = this.dragStart.sub(this.dragCurrent);
            if (force.mag() > 20) { const ratio = Math.abs(force.y) / (Math.abs(force.x) + 0.001); if (ratio > 0.36) { this.resetMultiplier(); this.fireNextShot(force.norm().mult(12)); } else { showToast("ÁôºÂ∞ÑËßíÂ∫¶ÈÅé‰Ωé"); } }
        }
    }

    fireNextShot(vel) {
        const recipe = this.ammoQueue.shift(); this.updateAmmoUI(); this.renderRecipeHUD(); 
        const shoot = (delay) => { setTimeout(() => { if (this.phase === 'combat') { this.spawnBullet(this.width/2, this.height-80, vel, recipe); audio.playShoot(); } }, delay / this.timeScale); };
        shoot(0); if (recipe.multicast > 0) { for(let i=1; i<=recipe.multicast; i++) { shoot(i * 300); } }
    }
    spawnBullet(x, y, vel, recipe) {
        this.projectiles.push(new Projectile(x, y, vel, recipe));
        if (recipe.scatter > 0) { for (let i = 1; i <= recipe.scatter; i++) { const sign = i % 2 === 0 ? -1 : 1; const multiplier = Math.ceil(i / 2); const angleOffset = 0.2 * multiplier * sign; const newVel = vel.rotate(angleOffset); const copyRecipe = { ...recipe, scatter: 0, chainPayload: null }; this.projectiles.push(new Projectile(x, y, newVel, copyRecipe, true)); } }
    }
    createExplosion(x, y, color) { for(let i=0; i<10; i++) { this.particles.push(new Particle(x, y, color || '#f87171')); } }
    createShockwave(x, y) { this.shockwaves.push(new Shockwave(x, y)); }
    createHitFeedback(x, y) {
        this.floatingTexts.push(new FloatingText(x, y, "+1"));
        if(this.currentSession) {
            this.updateHitProgress(this.currentSession.currentHits, this.currentSession.nextTriggerThreshold);
        }
    }
    compileCollectionToRecipe(marbleDef, collectedTypes, hasMulticast) {
        const recipe = { damage: 2, bounce: 0, pierce: 0, scatter: 0, explosive: marbleDef.type === 'redStripe', chainPayload: null, multicast: 0 };
        collectedTypes.forEach(t => { if (t === 'bounce') recipe.bounce += 1; if (t === 'pierce') recipe.pierce += 1; if (t === 'scatter') recipe.scatter += 1; if (t === 'damage') recipe.damage += 2; });
        return recipe;
    }
    updateGatheringQueueUI() {
        const q = document.getElementById('gathering-queue'); q.innerHTML = '';
        for(let i = this.activeMarbleIndex; i < this.marbleQueue.length; i++) {
            const m = this.marbleQueue[i]; const d = document.createElement('div'); d.className = 'queue-dot flex-shrink-0'; d.style.background = m.type === 'rainbow' ? CONFIG.colors.marbleRainbow : m.getColor(); q.appendChild(d);
        }
    }
    updateHitProgress(val, target) {
        const textEl = document.getElementById('hit-text');
        const barEl = document.getElementById('hit-bar');
        if (textEl) textEl.innerText = `${val}/${target}`;
        if (barEl) {
             const pct = target > 0 ? Math.min(100, (val/target)*100) : 0;
             barEl.style.width = `${pct}%`;
        }
    }
    updateAmmoUI() {
        const c = document.getElementById('ammo-queue'); if (!c) return; c.innerHTML = '';
        this.ammoQueue.forEach((recipe, i) => { const d = document.createElement('div'); d.className = `ammo-indicator ${i === 0 ? 'active' : ''}`; if (recipe.explosive) d.style.borderColor = '#fca5a5'; else if (recipe.chainPayload) d.style.borderColor = '#c084fc'; if (recipe.multicast > 0) d.style.background = CONFIG.colors.slotMulticast; c.appendChild(d); });
        const s = document.getElementById('current-bullet-stats');
        if (this.ammoQueue.length > 0) {
            const r = this.ammoQueue[0];
            let html = `<div class="flex justify-between"><span>‚öîÔ∏è ÂÇ∑ÂÆ≥</span> <span>${r.damage}</span></div>`;
            if (r.bounce) html += `<div class="flex justify-between text-green-300"><span>üü¢ ÂΩàÊÄß</span> <span>${r.bounce}</span></div>`;
            if (r.pierce) html += `<div class="flex justify-between text-red-300"><span>üî¥ Á©øÈÄè</span> <span>${r.pierce}</span></div>`;
            if (r.scatter > 0) html += `<div class="flex justify-between text-yellow-300"><span>üü° Êï£Â∞Ñ</span> <span>x${r.scatter}</span></div>`;
            if (r.explosive) html += `<div class="text-center text-red-400 font-bold mt-1">üí• ÁàÜÁÇ∏</div>`;
            if (r.multicast > 0) html += `<div class="text-center text-orange-400 font-bold mt-1">‚ö° ÈÄ£Â∞Ñ x${r.multicast}</div>`;
            s.innerHTML = html;
        } else { s.innerHTML = '<div class="text-slate-500 italic">Á©∫</div>'; }
    }

    loop() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        if (this.phase === 'gathering') this.updateGathering(); else if (this.phase === 'combat') this.updateCombat();
        requestAnimationFrame(() => this.loop());
    }

    updateGathering() {
        this.pegs.forEach(p => { p.update(); p.draw(this.ctx, p.radius); }); this.specialSlots.forEach(s => s.draw(this.ctx));
        
        // Ghost Marble
        if (this.dropBalls.length === 0 && this.activeMarbleIndex < this.marbleQueue.length) {
            const m = this.marbleQueue[this.activeMarbleIndex]; this.ctx.globalAlpha = 0.5; this.ctx.beginPath(); this.ctx.arc(this.lastMousePos.x, 30, 12, 0, Math.PI * 2); this.ctx.fillStyle = m.type === 'rainbow' ? '#fff' : m.getColor(); this.ctx.fill(); this.ctx.strokeStyle = '#fff'; this.ctx.lineWidth = 1; this.ctx.setLineDash([2, 2]); this.ctx.stroke(); this.ctx.setLineDash([]); this.ctx.globalAlpha = 1.0;
        }

        let needsHudUpdate = false;
        for (let i = this.dropBalls.length - 1; i >= 0; i--) {
            const b = this.dropBalls[i]; const prevCollectedCount = b.def.collected.length; const result = b.update(this.pegs, this.specialSlots, this.width, this.height, this.timeScale); b.draw(this.ctx);
            if (b.def.collected.length !== prevCollectedCount) needsHudUpdate = true;
            if (result) {
                if (result.action === 'split' || result.action === 'rainbow_split') {
                    this.dropBalls.splice(i, 1); b.session.activeBalls += 1; 
                    const shard1 = new DropBall(result.pos.x - 12, result.pos.y, b.def, b.session); shard1.isRainbowShard = true; shard1.vel = result.vel.rotate(-0.3); shard1.radius = Math.max(8, b.radius * 0.8); shard1.canTriggerSplitSlot = false; 
                    const shard2 = new DropBall(result.pos.x + 12, result.pos.y, b.def, b.session); shard2.isRainbowShard = true; shard2.vel = result.vel.rotate(0.3); shard2.radius = Math.max(8, b.radius * 0.8); shard2.canTriggerSplitSlot = false; 
                    this.dropBalls.push(shard1, shard2);
                } else if (result === 'finished') {
                    this.dropBalls.splice(i, 1); b.session.activeBalls--;
                    if (b.session.activeBalls <= 0) {
                        let finishedRecipe = this.compileCollectionToRecipe(b.def, b.session.collected, false); finishedRecipe.multicast = b.session.multicast;
                        this.ammoQueue.push(finishedRecipe); this.finishMarbleProcessing();
                    }
                }
            }
        }
        for(let i=this.floatingTexts.length-1; i>=0; i--) { let t = this.floatingTexts[i]; t.update(this.timeScale); t.draw(this.ctx); if(t.life <= 0) this.floatingTexts.splice(i,1); }
        for(let i=this.particles.length-1; i>=0; i--) { let p = this.particles[i]; p.update(this.timeScale); p.draw(this.ctx); if(p.life <= 0) this.particles.splice(i,1); }
        
        if(needsHudUpdate) this.renderRecipeHUD();

        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.03)'; this.ctx.fillRect(0, 0, this.width, this.height * 0.4); this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; this.ctx.beginPath(); this.ctx.moveTo(0, this.height * 0.4); this.ctx.lineTo(this.width, this.height * 0.4); this.ctx.stroke();
    }
    
    finishMarbleProcessing() {
        this.activeMarbleIndex++; this.updateGatheringQueueUI(); this.renderRecipeHUD(); 
        if (this.activeMarbleIndex >= this.marbleQueue.length && this.dropBalls.length === 0) { setTimeout(() => this.startCombatPhase(), 500); }
    }
    advanceWave() { this.enemies.forEach(e => e.advance(this.enemyHeight)); const rows = new Set(this.enemies.filter(e=>e.active).map(e => Math.floor(e.pos.y))); let spawnCount = 1; if (rows.size < 3) spawnCount = 2; this.spawnEnemyRow(spawnCount); this.round++; this.prevRoundDamage = this.roundDamage; this.roundDamage = 0; document.getElementById('round-num').innerText = this.round; showToast(`Round ${this.round}`); }
    checkDefeat() { for(let e of this.enemies) { if (e.active && e.pos.y > this.defeatLineY) return true; } return false; }

    updateCombat() {
        this.ctx.strokeStyle = '#60a5fa'; this.ctx.lineWidth = 3; this.ctx.beginPath(); this.ctx.moveTo(0, this.height); this.ctx.lineTo(this.width, this.height); this.ctx.stroke();
        this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)'; this.ctx.setLineDash([5, 5]); this.ctx.beginPath(); this.ctx.moveTo(0, this.defeatLineY); this.ctx.lineTo(this.width, this.defeatLineY); this.ctx.stroke(); this.ctx.setLineDash([]); this.ctx.fillStyle = 'rgba(239, 68, 68, 0.1)'; this.ctx.fillText("Èò≤Á¶¶Â∫ïÁ∑ö", 60, this.defeatLineY - 10);
        let activeEnemies = 0; this.enemies.forEach(e => { if (e.active) { e.update(this.timeScale); e.draw(this.ctx); activeEnemies++; } });
        if (this.gameOver) { document.getElementById('combat-message').innerHTML = '<span class="text-red-400 font-bold text-4xl">Èò≤Á∑öÂ§±ÂÆà</span><br><span class="text-sm pointer-events-none">ÈªûÊìäÈáçË©¶</span>'; if (this.isDragging) location.reload(); return; }
        for (let i = this.projectiles.length - 1; i >= 0; i--) { const p = this.projectiles[i]; p.update(this.width, this.height, this.enemies, (spawnInfo) => { this.spawnBullet(spawnInfo.x, spawnInfo.y, spawnInfo.vel, spawnInfo.config); }, this.timeScale); p.draw(this.ctx); if (p.destroyed) this.projectiles.splice(i, 1); }
        for(let i=this.particles.length-1; i>=0; i--) { let p = this.particles[i]; p.update(this.timeScale); p.draw(this.ctx); if(p.life <= 0) this.particles.splice(i,1); }
        for(let i=this.shockwaves.length-1; i>=0; i--) { let s = this.shockwaves[i]; s.update(this.timeScale); s.draw(this.ctx); if(s.alpha <= 0) this.shockwaves.splice(i,1); }
        if (this.checkDefeat()) this.gameOver = true;
        if (this.ammoQueue.length === 0 && this.projectiles.length === 0 && !this.gameOver) { document.getElementById('combat-message').innerHTML = '<div class="bg-black/50 p-4 rounded-xl backdrop-blur-md border border-blue-500/50 pointer-events-none"><span class="text-blue-300 font-bold text-xl block mb-2">ÂΩàËó•ËÄóÁõ°</span><span class="text-sm text-slate-300">ÈªûÊìäÊî∂ÈõÜÊñ∞ÂΩàËó•</span></div>'; } else { if (!this.gameOver) document.getElementById('combat-message').innerHTML = ''; }
        if (this.isDragging && this.projectiles.length === 0 && this.ammoQueue.length > 0) {
            const start = new Vec2(this.width/2, this.height-80); this.ctx.beginPath(); this.ctx.moveTo(start.x, start.y); let force = this.dragStart.sub(this.dragCurrent);
            if(force.mag() > 20) { let end = start.add(force.norm().mult(200)); this.ctx.lineTo(end.x, end.y); this.ctx.strokeStyle = '#fff'; this.ctx.setLineDash([4, 4]); this.ctx.stroke(); this.ctx.setLineDash([]); this.ctx.beginPath(); this.ctx.arc(end.x, end.y, 4, 0, Math.PI*2); this.ctx.fillStyle = '#fff'; this.ctx.fill(); 
                this.ctx.save(); this.ctx.translate(start.x, start.y); this.ctx.rotate(Math.atan2(force.y, force.x) + Math.PI);
                this.ctx.fillStyle = '#6366f1'; this.ctx.beginPath(); this.ctx.arc(0, 0, 15, 0, Math.PI*2); this.ctx.fill(); this.ctx.fillStyle = '#818cf8'; this.ctx.fillRect(10, -6, 12, 12); this.ctx.restore();
            }
        } else if (this.projectiles.length === 0) {
             const start = new Vec2(this.width/2, this.height-80); this.ctx.fillStyle = '#475569'; this.ctx.beginPath(); this.ctx.arc(start.x, start.y, 12, 0, Math.PI*2); this.ctx.fill();
        }
    }
}
const game = new Game();
</script>
</body>
</html>